изменения данных форм

input
при каждом изменении данных в форме - вставка текста, голосовой воод ит

change
после ввода данных в элементе формы
change происходи ПОСЛЕ окончания изменений = при потере фокуса. в остальных элем происходит сразу

cut/copy/paste события вырезания, копи и вставки

формы
сетевые запросы

fetch
матрешка
часть BOM - browser object model и не определяется стандартом ECMAScript. а WHATWG и W3C. Появился в ECMAScript7 2016. более ранни браузеры не поддерживают
в JS это промис, но с большими возможностями, чем могут предостиавить промисы

вместо (?) HTTP request

let promise - fetch(url, options)
url - обязательный, адрес сервера, куда едет запрос
options - объект, в кот параметры запроса, метод, заголовки и тело запроса

ДАННЫЕ

1. сначала асинхр ответ в виде встроенного Response - в нем код статуса HTTP
   response.status - код ответа сервера, сайт доступен и нет ли ошибок

response.ok - статус в диапазоне 200-299

2. потом. для получения тела ответа нужно дополнительно вызвать метод. в классе Response есть несколько методов, позволяющие получить асинхронно тело ответа

методы Response

response.json()
response..text()
response.blob()
response.arrayBuffer()
response.formData()
response.body() - объект ReadableStream - считывааем тело запроса по частям
response.headers - коллекция заголовков ответов, похожая на Map

бесплатные апи примеры - кэтфактс

FormData - автогенерим готовый объект из формы и отправляют посредством сетевых запросов на сервера
const FormData = new FormData(form)

параметр не обязателен, но если передадим элемент формы, о форма прикрепится к телу запроса и будет отправлена на сервер в нужном виде. при этом установится заголовок Content-Type: multipart/form-data

<!-- прокрутка скролл из лекции 2

window.addEventListener('scroll', () => {
document.getElementById('showScroll').innerHTML = scrollY + 'px';
});

подгрузка следующей при достижении низа текущей и встраиванием содержимого ниже. Доп потребности показать доп содержимое. -->

fetch позволяет отобразить процесс получения данныхотслеживание процесса отправки - не поддерживается fetch!
но можно обратиться к XMLHttpRequest

для отслеживания хода загрузки можно использовать response.body

AbortControlle - класс дял отмены fetch и других асинхронных!
для фетч в параметрах свойство сигнал, в него пишем контроллер созданный с помощью абортконтроллер и далее в нужном месте вызываем аборт

const controller = new AbortController();
fetch(url, {
signal:controller.signal}); вот наша опция

controller.abort();

_кросдоменные запросы_
CORS Cross original resoupce sharing - политика запрещает загружатькакие-либо ресурсы с других доменов. иначе вражины обратятся к нашему серверу и получат доступ к данным

простые: HEAD GET POST
и у них ТОЛЬКО такие заголовки:

Accept
Accept-language
Content-language
Content-type со значениями application/x-www-form-urlencoded, multipart/form-data или text/plain

ПРИ ПРОСТОМ запросе браузер устанавливает звголовки Origin с указание источника, внутри котого может быть домен, поддомен и потребности
Сервер проверяет заголовок
Далее если находит - ставит заголовок Access-Control-Allow-Origin
если нет - блокирует запрос

если на сервере разрешен доступ к любому Origin, тов ответе будет звездочка `Access-Control-Allow-Origin: *`

Любой здругой запрос - НЕ простой.

_WebSocket_

это протокол передачи данных в сети
он создает постоянное соединение между сервером и клиентом и позволяет инициировать передачу данных серверомЧаты, онлайн-игры, дял кот требуется постоянное слежение

существует спецкласс WebSocket, 2 метода и 4 события
const webSocket = new webSocket('wss://gb.ru')

url указываем специальным протоколом ws (ssl сертификат) или wss

события -
open
close
error
message

отправляем с помощью send()

текстовые, бинарные, пинг, фрейм закрытия, служебные
