_AE addEventListener_

<button onclick="handler()"> устарело!

атрибут html элем передается коду в кавычках, сейчас это функция handler
alert не надо!
это устарело и не надо юзать, но чтоб быстро проверить - ок

let button.docoment.getElementsById('button);
buttononclick = () => {} - DOM обработчик  
минус - если два онклика то нижний отработает а верхний забудется

button.addEventListener(event, handler, options); - наш модный выбор!

эвент, что должно отработать и опции ( могут быть другие события, недоступные к добавлению иными способами)

_всплытие событий_

событие регистрируется в элем, где оно произошло.
потом - в родителе,
потомв родителе родителя
итд до верха

= bubble - пузырек, который всплывает

почти все события всплывают
всплытие можно отменить с помощью метода stopPropagation()

_погружение событий_

используется редкко
поймать погружение можем только с e.addEventListener()

погружается автоматически, управлять (почти)не можем. и, ессно, сначала погружается, потом всплывает

модальное окно - обычня кнопка - жмем и получаем окошко с производльным контентомю нажали вне - закрылось

генер событий польз - 37:26

new Event()

конструктор Event - созадет событиедля запуска метод dispatchEvent

isTrusted ыернет нам ответ, является ли событие встроенным

св-во preventDefault отменит действие браузера по умолчанию

_мышь_

mousedown
mouseup
clickdbclick
mouseover
mouseout
mousemove
contexmenu

не всплывающие, не разделяют элемент и его потомков, считается что это 1 элемент
mouseenter - курсор мыши наведен на элемент
mouseleave - курсор покинул зону элемента

_клава_

keydown
keyup

у события есть свойство с кодом code нажатой клавиши и её ключом key
ключ это символ клавишикод - физический код клавишикод
для системных:
shiftKey, altKey (Opt Mac), ctrlKey,metaKey(cmd Mac)

_scroll_

При достижении низа при прокрутке - появляется нвоое содержимое
window.addEventListener("scroll", ()=> {
docoment.getElementsById('showScroll').innerHTML = scrollY + 'px';
})
